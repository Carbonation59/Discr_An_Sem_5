\section{Описание}
Требуется реализовать алгоритм динамического программирования, решающий поставленную задачу: найти наибольший прямоугольник, состоящий из нулей. Для решения этой задачи был использован метод гистограмм. В качестве высот столбцов гистограммы будут выступать количество подряд идущих нулей сверху у ячейки. Анализируем гистограмму: если столбцы неубывают по высоте, то продолжаем её построение, иначе фиксируем, какая наибольшая площадь прямоугольника могла быть получена до падения гистограммы, а затем снова продолжаем алгоритм. Подсчёт площади осуществляется так: запоминается количество стобцов в текущем неубывающем куске гистограммы и умножается на высоту наименьшего из столбцов. Из всех таких площадей выбирается наибольшая и выводится в качестве ответа.

\pagebreak

\section{Исходный код}
В коде используется алгоритм мемоизации: смысла хранить всю матрицу нет, поэтому хранятся только текущая и предыдущая её строки. В стэке содержатся высоты столбцов гистограммы и индексы, на которых находятся эти стобцы. Когда высота верхнего элемента стека меньше текущего, то мы начинаем доставать все элементы до тех пор, пока не найдём элемент меньше или равный по высоте текущему. В процессе "вытаскивания"\quadэлементов подсчитывается промежуточная площадь: из текущего индекса вычитается индекс вытащенного элемента и это умножается на высоту вытащенного элемента. Значение в переменной $ans$ обновляется, если оно меньше получившегося результата. 
Когда же высота верхнего элемента стека не меньше высоты текущего элемента, он добавляется в верхушку стека.
Алгоритм продолжается до тех пор, пока не будут пройдены все строки матрицы.

\begin{lstlisting}[language=C]
#include <iostream>
#include <vector>
#include <stack>

using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr); cout.tie(nullptr);
    int n, m;
    cin >> n >> m;
    int ans = 0;
    vector<int> matrix1(m);
    vector<int> matrix2(m);
    char a;
    for (int i = 0;i < n;i++) {
        fill(matrix2.begin(), matrix2.end(), 0);
        stack<pair<int, int>> s; 
        for (int j = 0;j < m;j++) {
            cin >> a;
            if (a - '0' == 1) {
                continue;
            }
            else if (i == 0) {
                matrix2[j] = 1;
            }
            else {   // высчитываем колонну подряд идущих нулей
                matrix2[j] = matrix1[j] + 1;
            }
        }
        s.push({ 0, 0 }); // заполняем стек для гистограммы первым элементом
        int high;
        int width;
        int tmp;
        for (int j = 0;j < m;j++) {
            if (matrix2[j] > (s.top()).first) {  // продолжаем рост гастограммы
                s.push({ matrix2[j], j });
            }
            else if (matrix2[j] < (s.top()).first) {  // гистограмма понизит максимальную высоту
                high = 1e3;
                width = 0;
                while (matrix2[j] < (s.top()).first) {
                    high = min(high, (s.top()).first);
                    width = j - (s.top()).second;
                    tmp = (s.top()).second;
                    ans = max(ans, high * width);
                    s.pop();
                }
                if (matrix2[j] > (s.top()).first) {
                    s.push({ matrix2[j], tmp });
                }
            }
            else {  // гистограмма сохраняет прошлую высоту
                continue;
            }

        }
        high = 1e3;
        width = 0;
        while (!s.empty()) {  // выводим оставшиеся элементы гистограммы
            high = min(high, (s.top()).first);
            width = m - (s.top()).second;
            ans = max(ans, high * width);
            s.pop();
        }
        swap(matrix1, matrix2);
    }
    cout << ans;
}
\end{lstlisting}


\section{Консоль}
\begin{alltt}
root@DESKTOP-5HM2HTK:~# cat <test
4 5
01011
10001
01000
11011
root@DESKTOP-5HM2HTK:~# g++ lab7.cpp
root@DESKTOP-5HM2HTK:~# ./a.out <test
4
root@DESKTOP-5HM2HTK:~#
\end{alltt}
\pagebreak

